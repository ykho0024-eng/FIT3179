<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <title>Victim-Perpetrator Chord Diagram</title>
  <style>
    body { 
      margin: 0; 
      padding: 5px; 
      font-family: Arial, sans-serif; 
      background: white; 
    }
    .container { 
      max-width: 420px; 
      margin: 0 auto; 
      background: white; 
      padding: 10px;
    }
    h1 { 
      text-align: center;
      color: #333; 
      margin-bottom: 5px; 
      font-size: 16px;
      font-weight: bold;
    }
    .subtitle { 
      text-align: center;
      color: #666; 
      margin-bottom: 10px; 
      font-size: 11px; 
    }
    .annotation {
      text-align: center;
      color: #888;
      font-size: 10px;
      font-style: italic;
      margin-bottom: 15px;
      padding: 6px;
      background: #f9fafb;
      border-radius: 4px;
    }
    .legend {
      margin-bottom: 15px;
    }
    .legend-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 11px;
      text-align: center;
    }
    .legend-items {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .legend-item:hover {
      background-color: #f0f0f0;
    }
    .legend-item.active {
      background-color: #e0e7ff;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    .legend-text {
      font-size: 10px;
      line-height: 1.2;
    }
    #vis { 
      display: flex; 
      justify-content: center;
      overflow: visible;
      margin-bottom: 10px;
    }
    .ribbon {
      fill-opacity: 0.6;
      stroke-width: 1px;
      transition: fill-opacity 0.2s;
      cursor: pointer;
    }
    .ribbon:hover {
      fill-opacity: 0.9;
    }
    .ribbon.dimmed {
      fill-opacity: 0.1;
    }
    .ribbon.highlighted {
      fill-opacity: 1;
    }
    .group-arc {
      stroke: white;
      stroke-width: 1px;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .group-arc.dimmed {
      opacity: 0.3;
    }
    .group-label {
      font-size: 8px;
      font-weight: bold;
      fill: #333;
      text-anchor: middle;
    }
    .tooltip {
      position: absolute;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 3px;
      font-size: 10px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Victim-Perpetrator Relationships</h1>
    <p class="subtitle">Assault Cases by Gender and Relationship</p>
    <div class="legend">
      <div class="legend-title">Categories</div>
      <div class="legend-items" id="legend-items"></div>
    </div>
    <p class="annotation">ðŸ’¡ Click on any category to highlight their flows</p>
    <div id="vis"></div>
    <div class="tooltip"></div>
  </div>

  <script>
    // Data setup
    const categories = [
      "Male Victims",
      "Female Victims", 
      "Stranger",
      "Family/Intimate",
      "Friend",
      "Professional/Educational",
      "Other"
    ];

    // Flow data: [source_index, target_index, value]
    const flows = [
      [0, 2, 236.2],  // Male -> Stranger
      [0, 3, 42.4],   // Male -> Family/Intimate
      [0, 4, 32.7],   // Male -> Friend
      [0, 5, 80.5],   // Male -> Professional
      [0, 6, 55.1],   // Male -> Other
      [1, 2, 131.8],  // Female -> Stranger
      [1, 3, 98.8],   // Female -> Family/Intimate
      [1, 4, 21.3],   // Female -> Friend
      [1, 5, 64.0],   // Female -> Professional
      [1, 6, 53.8]    // Female -> Other
    ];

    // Create matrix with scaling to make perpetrator categories more visible
    const matrix = Array(categories.length).fill(0).map(() => Array(categories.length).fill(0));
    
    // Calculate total for scaling
    let victimTotal = 0;
    let perpTotal = 0;
    
    flows.forEach(([source, target, value]) => {
      matrix[source][target] = value;
      victimTotal += value;
    });
    
    // Calculate perpetrator totals
    for (let i = 2; i < categories.length; i++) {
      for (let j = 0; j < 2; j++) {
        perpTotal += matrix[j][i];
      }
    }
    
    // Apply scaling factor to make perpetrator arcs more visible
    // Scale up perpetrator side by adding proportional values
    const scaleFactor = 2.5; // Increase this to make perpetrator arcs even larger
    
    flows.forEach(([source, target, value]) => {
      // Add scaled value to reverse direction to make target arcs larger
      matrix[target][source] = value * scaleFactor;
    });

    // Color scheme
    const colors = {
      "Male Victims": "#3b82f6",
      "Female Victims": "#ef4444",
      "Stranger": "#10b981",
      "Family/Intimate": "#f59e0b",
      "Friend": "#8b5cf6",
      "Professional/Educational": "#06b6d4",
      "Other": "#ec4899"
    };

    // Dimensions - larger chord diagram, less white space
    const width = 400;
    const height = 400;
    const outerRadius = Math.min(width, height) * 0.47;
    const innerRadius = outerRadius - 20;

    // Create SVG
    const svg = d3.select("#vis")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("style", "max-width: 100%; height: auto;")
      .append("g")
      .attr("transform", `translate(${width / 2}, ${height / 2})`);

    // Create chord layout with custom sorting to group victims and perpetrators
    const chord = d3.chord()
      .padAngle(0.04)
      .sortSubgroups(d3.descending)
      .sortGroups((a, b) => {
        // Keep victims (0,1) on one side and perpetrators (2-6) on the other
        return a - b;
      });

    const arc = d3.arc()
      .innerRadius(innerRadius)
      .outerRadius(outerRadius);

    const ribbon = d3.ribbon()
      .radius(innerRadius);

    const chords = chord(matrix);

    // Tooltip
    const tooltip = d3.select(".tooltip");

    // State for selected category
    let selectedCategory = null;

    // Function to highlight ribbons based on selected category
    function highlightCategory(categoryIndex) {
      if (categoryIndex === null) {
        // Reset all
        svg.selectAll(".ribbon")
          .classed("dimmed", false)
          .classed("highlighted", false);
        svg.selectAll(".group-arc")
          .classed("dimmed", false);
        d3.selectAll(".legend-item")
          .classed("active", false);
        selectedCategory = null;
      } else {
        selectedCategory = categoryIndex;
        
        // Dim all ribbons first
        svg.selectAll(".ribbon")
          .classed("dimmed", true)
          .classed("highlighted", false);
        
        // Highlight ribbons connected to selected category
        svg.selectAll(".ribbon")
          .filter(d => d.source.index === categoryIndex || d.target.index === categoryIndex)
          .classed("dimmed", false)
          .classed("highlighted", true);
        
        // Dim non-connected arcs
        svg.selectAll(".group-arc")
          .classed("dimmed", d => d.index !== categoryIndex);
        
        // Highlight selected legend item
        d3.selectAll(".legend-item")
          .classed("active", (d, i) => i === categoryIndex);
      }
    }

    // Draw ribbons
    svg.append("g")
      .selectAll("path")
      .data(chords)
      .join("path")
      .attr("class", "ribbon")
      .attr("d", ribbon)
      .style("fill", d => colors[categories[d.target.index]])
      .style("stroke", d => d3.rgb(colors[categories[d.target.index]]).darker())
      .on("mouseover", function(event, d) {
        tooltip
          .style("opacity", 1)
          .html(`${categories[d.source.index]} â†’ ${categories[d.target.index]}<br/><strong>${d.source.value.toFixed(1)}k</strong> assaults`);
      })
      .on("mousemove", function(event) {
        tooltip
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 10) + "px");
      })
      .on("mouseout", function() {
        tooltip.style("opacity", 0);
      });

    // Draw groups (arcs)
    const group = svg.append("g")
      .selectAll("g")
      .data(chords.groups)
      .join("g");

    group.append("path")
      .attr("class", "group-arc")
      .attr("d", arc)
      .style("fill", d => colors[categories[d.index]])
      .on("click", function(event, d) {
        event.stopPropagation();
        if (selectedCategory === d.index) {
          highlightCategory(null);
        } else {
          highlightCategory(d.index);
        }
      })
      .on("mouseover", function(event, d) {
        if (selectedCategory === null) {
          tooltip
            .style("opacity", 1)
            .html(`${categories[d.index]}<br/><strong>${d.value.toFixed(1)}k</strong> total`);
        }
      })
      .on("mousemove", function(event) {
        tooltip
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 10) + "px");
      })
      .on("mouseout", function() {
        tooltip.style("opacity", 0);
      });

    // Add labels that follow arc direction but remain straight
    group.append("text")
      .each(d => { 
        d.angle = (d.startAngle + d.endAngle) / 2;
        d.midRadius = (innerRadius + outerRadius) / 2;
      })
      .attr("class", "group-label")
      .attr("transform", d => {
        const angleDegrees = d.angle * 180 / Math.PI;
        const radius = d.midRadius;
        
        // Position along arc
        const x = radius * Math.cos(d.angle - Math.PI / 2);
        const y = radius * Math.sin(d.angle - Math.PI / 2);
        
        // Rotate to follow arc tangent
        let rotation = angleDegrees;
        if (angleDegrees > 90 && angleDegrees < 270) {
          rotation += 180; // Keep text upright on left side
        }
        
        return `translate(${x}, ${y}) rotate(${rotation})`;
      })
      .style("text-anchor", "middle")
      .style("dominant-baseline", "middle")
      .style("fill", "white")
      .style("font-weight", "bold")
      .style("font-size", "8px")
      .text(d => {
        // Shorten long labels
        const label = categories[d.index].toUpperCase();
        if (label === "PROFESSIONAL/EDUCATIONAL") {
          return "PROF/EDUC";
        }
        return label;
      });

    // Create legend items
    const legendItems = d3.select("#legend-items");
    
    categories.forEach((cat, idx) => {
      const item = legendItems.append("div")
        .attr("class", "legend-item")
        .on("click", function() {
          if (selectedCategory === idx) {
            highlightCategory(null);
          } else {
            highlightCategory(idx);
          }
        });
      
      item.append("div")
        .attr("class", "legend-color")
        .style("background-color", colors[cat]);
      
      item.append("span")
        .attr("class", "legend-text")
        .text(cat);
    });

    // Click outside to reset
    d3.select("body").on("click", function(event) {
      if (!event.target.closest(".legend-item") && 
          !event.target.closest(".group-arc") && 
          !event.target.closest(".ribbon")) {
        highlightCategory(null);
      }
    });
  </script>
</body>
</html>
